= Perfective Common for TypeScript
:mdn-js-globals: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
:perfective-common: https://github.com/perfective/ts.common/tree/main

== Installation

[source,bash]
----
npm install @perfective/common
----

After the installation you can read the full compiled documentation in the `node_modules/@perfective/common/docs.html`.

== Key Features

The `@perfective/common` package facilitates writing highly readable functional code.
It focuses on providing functions to handle ECMAScript types
and to compose functions together easily.


=== Maybe monad

The `link:{perfective-common}/src/maybe/index.adoc[@perfective/common/maybe]` package
provides a Maybe monad implementation.

It allows you to write and compose functions that accept only present (defined and non-null) values.
It helps avoid additional complexity and noise when handling `null` and `undefined` values.

For example, consider you have the `User` and `Name` types below and want to output a user’s full name.

[source,typescript]
----
interface User {
    name?: Name;
}

interface Name {
    first: string;
    last: string;
}
----

If you write functions that have to handle `null` and `undefined` values,
then you would have to write something like this:

[source,typescript]
----
function userNameOutput(user: User | null | undefined): string {
    if (isPresent(user)) {
        const name = fullName(user.name);
        if (isPresent(name)) {
            return name;
        }
    }
    throw new Error('User name is unknown');
}

function fullName(name: Name | null | undefined): string | null {
    if (isPresent(name)) {
        const trimmed = `${name.first} ${name.last}`.trim();
        if (isNotEmpty(trimmed)) {
            return trimmed;
        }
    }
    return null;
}
----

When using the `link:{perfective-common}/src/maybe/index.adoc[Maybe]` monad,
you can write simpler and more readable functions:

[source,typescript]
----
import { panic } from '@perfective/common/error';
import { just, Maybe, maybe } from '@perfective/common/maybe';
import { isNotEmpty, trim } from '@perfective/common/string';

function userNameOutput(user: User | null | undefined): string {
    return maybe(user)
        .pick('name') // <.>
        .onto(fullName) // <.>
        .or(panic('User name is unknown')); // <.>
}

function fullName(name: Name): Maybe<string> {
    return just(`${name.first} ${name.last}`)
        .to(trim) // <.>
        .that(isNotEmpty); // <.>
}
----
<.> `link:{perfective-common}/src/maybe/index.adoc#maybepick[Maybe.pick()]`
provides a strictly-typed "optional chaining" of the `Maybe.value` properties.
<.> `link:{perfective-common}/src/maybe/index.adoc#maybeonto[Maybe.onto()]`
(flat) maps a `Maybe.value` to another `Maybe`.
<.> `{perfective-common}/src/maybe/index.adoc#maybeor[Maybe.or()]`
extracts a `value` from the `Maybe` with a given fallback.
(or allows to throw an error).
<.> `link:{perfective-common}/src/maybe/index.adoc#maybethat[Maybe.that()]`
filters a value inside `Maybe`.
<.> `link:{perfective-common}/src/maybe/index.adoc#maybeto[Maybe.to()]` maps a value inside `Maybe` using a given callback.

In addition to these methods,
the `link:{perfective-common}/src/maybe/index.adoc[Maybe]` type also provides:
`link:{perfective-common}/src/maybe/index.adoc#maybeinto[Maybe.into()]`,
`link:{perfective-common}/src/maybe/index.adoc#maybewhich[Maybe.which()]`,
`link:{perfective-common}/src/maybe/index.adoc#maybewhen[Maybe.when()]`,
`link:{perfective-common}/src/maybe/index.adoc#maybeotherwise[Maybe.otherwise()]`,
and `link:{perfective-common}/src/maybe/index.adoc#maybethrough[Maybe.through()]` methods.


=== Result monad

The `link:{perfective-common}/src/result/index.adoc[@perfective/common/result]` package provides a `Result` monad
(a concrete case of an Either monad).
It allows you to treat errors as part of a function result
and chain processing of such results.

For example,
consider you are writing a function that loads a backend entity based on the user input.

.Example of the provided functions and types.
[source,typescript]
----
interface EntityRequest {
    entity: string;
    id: number;
}

interface User {
    id: number;
    username: string;
}

/**
 * @throws {Error} If a given input is empty or is not a number.
 */
declare function numberInput(input: string): number;

declare function request(entity: string): (id: number) => EntityRequest;

declare function user(request: EntityRequest): User;
----

Writing an imperative code, you would have:

[source,typescript]
----
function userOutput(input: string): User {
    let id: number;
    try {
        id = numberInput(input);
    }
    catch {
        id = 0;
    }
    const userRequest = request('user');
    return user(userRequest(id));
}
----

Using the `Result` your code would be:

[source,typescript]
----
import { Result, resultOf } from '@perfective/common/result';

function userOutput(id: string): Result<User> {
    return resultOf(() => numberInput(id))
        .otherwise(0)
        .to(request('user'))
        .to(user);
}
----

The `Result` link:{perfective-common}/src/result/index.adoc#using-result-with-promise[integrates]
with the `Promise` using the `promisedResult()` and `settledResult()` functions.


=== Chained Exceptions

The ECMA `Error` class does not store a previous error.
This is inconvenient, as it requires either manually adding a previous error message to a new error.
Or worse, skip providing the previous error altogether.

Chaining previous errors is helpful for debugging.
Especially in async environments, when most of the stack trace is full of useless function calls like `next()`
or on the frontend with packed code and renamed functions.

The `link:{perfective-common}/src/error/index.adoc[@perfective/common/error]` package provides the `Exception` class
to make logging and debugging of productions code easier.
It supports three features:

* providing a previous error (allows to stack errors);
* using a message template with string tokens (allows to localize and format messages);
* storing additional context (simplifies logging and debugging).

.Using the `Exception` class and its constructors.
[source,typescript]
----
import { causedBy, chained, exception, unknownError } from '@perfective/common/error';

interface FetchRequest {
    method: string;
    url: string;
}

interface User {}

function numberInput(input: string): number {
    const id = Number(input);
    if (Number.isNaN(id)) {
        throw exception('Input {{value}} is not a number', { // <.>
            value: input,
        });
    }
    return id;
}

function userRequest(id: string): FetchRequest {
    try {
        const userId = numberInput(id);
        return {
            method: 'GET',
            url: `user/${userId}`,
        };
    }
    catch (error: unknown) { // <.>
        throw causedBy(unknownError(error), 'Invalid user id {{id}}', { // <.>
            id,
        });
    }
}

async function userResponse(request: FetchRequest): Promise<User> {
    return fetch(request.url, {
        method: request.method,
    });
}

async function user(id: string): Promise<User> {
    return Promise.resolve(id)
        .then(userRequest)
        .then(userResponse)
        .catch(chained('Failed to load user {{id}}', { // <.>
            id,
        }));
}
----
<.> Use the `exception()` function to instantiate an initial `Exception` without previous errors.
<.> Use the `unknownError()` function to wrap a possible non-`Error` value.
<.> When you use a `try-catch` block,
use the `causedBy()` function to create an `Exception` with a previous error.
<.> Use the `chained()` function to create a callback to chain an `Error`
(for example, in `Promise` or a `Result`).


When you want to output a chained `Exception`,
you can use the `Exception.toString()` method.
For the example above, the output may look like this:

[source,text]
----
Exception: Failed to load user `A`
    - Exception: Invalid user id `A`
    - Exception: Input `A` is not a number
----

If you want to log an `Exception` for debugging purposes, use the `chainedStack()` function.
It will return a similar chain of messages as above,
but each message will also contain a stack trace for each error.

Read more about the functions to handle the built-in JS errors and the `Exception` class in the
`link:{perfective-common}/src/error/index.adoc[@perfective/common/error]` package docs.


== Packages

Packages are organized and named around their primary type:

* `link:{perfective-common}/src/value/index.adoc[@perfective/common]`
— functions and types to handle types (e.g., `TypeGuard` interface), `null`, `undefined`, and `void` values.
+
* `link:{perfective-common}/src/array/index.adoc[@perfective/common/array]`
— functions and types for handling
link:{mdn-js-globals}/Array[arrays].
+
* `link:{perfective-common}/src/boolean/index.adoc[@perfective/common/boolean]`
— functions and types to handle
`link:{mdn-js-globals}/Boolean[boolean]` values.
+
* `link:{perfective-common}/src/error/index.adoc[@perfective/common/error]`
— functions and types to handle
`link:{mdn-js-globals}/Error[Error]`
and related classes.
+
* `link:{perfective-common}/src/function/index.adoc[@perfective/common/function]`
— functions and types for functional programming.
+
* `link:{perfective-common}/src/match/index.adoc[@perfective/common/match]`
— functions and types for a functional style `switch-case`.
+
* `link:{perfective-common}/src/maybe/index.adoc[@perfective/common/maybe]`
— a `Maybe` monad (https://en.wikipedia.org/wiki/Option_type[Option type]) implementation.
+
* `link:{perfective-common}/src/number/index.adoc[@perfective/common/number]`
— functions and types to handle
link:{mdn-js-globals}/Number[numbers].
+
* `link:{perfective-common}/src/object/index.adoc[@perfective/common/object]`
— functions and types for handling the
`link:{mdn-js-globals}/Object[Object]` class.
+
* `link:{perfective-common}/src/promise/index.adoc[@perfective/common/promise]`
— functions and types to handle the
`link:{mdn-js-globals}/Promise[Promise]` class.
+
* `link:{perfective-common}/src/result/index.adoc[@perfective/common/result]`
— a `Result` monad (https://en.wikipedia.org/wiki/Result_type[Result type]) implementation.
+
* `link:{perfective-common}/src/string/index.adoc[@perfective/common/string]`
— functions and types to handle
link:{mdn-js-globals}/String[strings].

The packages have full unit test coverage.

[IMPORTANT]
====
The code provided by this project relies on strict https://www.typescriptlang.org[TypeScript] compiler checks.
Using these packages in regular JS projects may produce unexpected behavior and is undocumented.
For example,
a function that declares an argument as _required_ relies on strict TSC `null` checks
and may not additionally check the value for `null`.
====
