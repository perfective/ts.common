= Maybe monad

`@perfective/common/maybe` package provides an https://en.wikipedia.org/wiki/Option_type[Option type] implementation.
It is inspired by the Haskell
`link:https://en.wikibooks.org/wiki/Haskell/Understanding_monads/Maybe[Maybe]` monad
and satisfies the https://en.wikipedia.org/wiki/Monad_(functional_programming)#Analysis[monad laws].

`Maybe` type simplifies handling of the absent (`null`/`undefined`) values
and provides methods that are called only when the value is present.
It allows the creation of chained calls similar to `Promise.then()` and RxJS `pipe()`.


== Handling `null` and `undefined` values

In JavaScript, two types represent an "absence" of value: `undefined` and `null`.
So the dichotomies like `Just | Nothing` and `Some | None` do not fit precisely
and require additional logic to cover all the cases: `T | null | undefined`.
For example, when you create a new `Maybe<T>` with a `null` value,
it has to maintain the value as `null` and should not change it to `undefined`.

.`Maybe<T>` maintains the original value.
[source,typescript]
----
import { maybe, naught, nothing } from '@perfective/common/maybe';
import { isGreaterThan } from '@perfective/common/number';

maybe(3.14).value === 3.14;

maybe(undefined).value === undefined;
nothing().value === undefined; // <.>
maybe(3.14)
    .that(isGreaterThan(4))
    .value === undefined; // <.>

maybe(null).value === null;
naught().value === null; // <.>
maybe(null)
    .that(isGreaterThan(4))
    .value === null; // <.>
----
<.> The `nothing()` function is the default unit function for `Nothing<T>`
and returns a memoized `new Nothing(undefined)`.
<.> By default, `Maybe` uses `undefined` for the absent value.
<.> The `naught()` function is the secondary unit function for `Nothing<T>`
and returns a memoized `new Nothing(null)`.
<.> If the original value is `null`,
`null` will be returned as an absent value after all transformations.

It is not always desired to have both `undefined` and `null` excluded.
For example, consider you have a field in an API that is `null` when there is no data,
but the field is not returned if a user does not have access to it.
In this case, you may prefer to fall back from `null` to a default value
but to throw an error for `undefined`.

To cover these cases, `@perfective/common/maybe` provides additional types:

* `Nullable<T>` that considers `null` as _absent_ and `undefined` as _present_:
** `Only<T>` represents a present value;
** `Nil<T>` represents an absent value.
+
* `Optional<T>` that considers `undefined` as _absent_ and `null` as _present_:
** `Some<T>` represents a present value;
** `None<T>` represents an absent value.

.The original absent value (`null` or `undefined`) is maintained through transformations.
[source,typescript]
----
import { nullable, optional } from '@perfective/common/maybe';
import { isGreaterThan } from '@perfective/common/number';

nullable(3.14)
    .that(isGreaterThan(4))
    .value === null; // <.>

optional(3.14)
    .that(isGreaterThan(4))
    .value === undefined; // <.>
----
<.> `Nullable<T>` returns `null` when the value is absent (`Nil<T>`)
<.> `Optional<T>` returns `undefined` when the value is absent (`None<T>`).


== Preserving the monad type

This package strictly preserves the type of the monad.
For example,
if you have a `Just` type and apply a function that returns a present value,
then the result will also be of type `Just`.

.Difference between `Maybe`, `Just` and `Nothing` contexts.
[source,typescript]
----
function maybeDecimal(value: number | null | undefined): Maybe<string> {
    return maybe(value).to(v => v.toString(10)); // <.>
}

function justDecimal(value: number): Just<string> {
    return maybe(value).to(v => v.toString(10)); // <.>
}

function nothingDecimal(value: null | undefined): Nothing<string> {
    return maybe<number>(value).to(a => a.toString(10)); // <.>
}
----
<.> The argument of the `maybeDecimal` function is `number | null | undefined`.
So the `maybe()` function returns `Maybe<number>`
(which is either `Just<number>` or `Nothing<number>`).
The result of the function may also be `Just` or `Nothing`,
because we can not be sure that the `to()` method will be called,
even the `v => v.toString(10)` returns a `string` for any `number` input.
+
<.> The argument of the `justDecimal` is always a `number`.
The `maybe()` function returns `Just<number>`,
because the value is _always_ present.
`maybe` has a custom overload signature,
and compiler also knows,
that `maybe` returns `Just<number>`.
+
As the `v => v.toString(10)` result is always a `string`,
compiler also knows that the result of the whole chain remains present.
And the return type can be set as `Just<string>`.
+
<.> Similarly, when the value can only be `null` or `undefined`,
the `maybe()` function returns `Nothing<number>` in compile time and in runtime.
And the return type of the whole chain can be set to `Nothing<string>`.


== Using `onto()` and `to()` methods

Both `Maybe.onto()` and `Maybe.to()` methods  apply a given function
only when the value is present.
But `onto` requires the function to return the next `Maybe` instance,
while `to` will wrap the returned value into `Maybe`.

When writing functions that use Maybe chaining,
the best practice is to return the packed value (as `Maybe`, `Just`, or `Nothing`).
This allows a consumer of the function to decide how they want to unpack it
or to keep it as `Maybe` for the next chain.

When you have a function of non-Maybe types,
then you have to use `Maybe.to`.

.For example, consider you are writing a function to parse a date.
[source,typescript]
----
function isValidDate(date: Date): boolean {
    return date.toString() !== 'Invalid Date'; <.>
}

function parsedDate(input: string): Maybe<Date> { <.>
    const date = new Date(input);
    if (isValidDate(date)) {
        return just(date);
    }
    return nothing();
}

interface BlogPost {
    createdAt: string;
}

function dbDate(input: BlogPost): Date { <.>
    return just(input)
        .pick('createdAt')
        .onto(parsedDate)
        .or(panic('Invalid "Created At" Date'));
}

function jsonDate(input: BlogPost): string|null { <.>
    return just(input)
        .pick('createAt')
        .onto(parsedDate)
        .or(null);
}

function formattedCreatedAt(input: BlogPost): string { <.>
    return just(input)
        .pick('createdAt')
        .onto(parsedDate)
        .or('Unknown date');
}
----
<.> The `new Date()` constructor creates a `Date` object even for
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/Date#return_value[invalid inputs].
<.> We postpone the decision of how to handle an invalid value.
By returning `Maybe<Date>` (instead of `Date|null` or throwing an error)
we allow consumers of the function to make a decision that is most appropriate to their situation.
<.> When we record value to the database,
it has to be valid.
So we must throw an error when the date is invalid.
<.> When we return an API response,
a `null` for invalid dates is ok.
<.> When we try to format a date in the UI,
we may prefer a readable fallback.


== Reference

There are three distinct type groups available in this package:

* `Maybe<T>` is `Just<T>` or `Nothing<T>`;
* `Optional<T>` is `Some<T>` or `None<T>`;
* `Nullable<T>` is `Only<T>` or `Nil<T>`.

The examples below are shown primarily for the `Maybe` type,
as the most used.


=== `onto(flatMap)`

`Maybe.onto()` is the _bind_ operator (`>>=`)
that satisfies the three https://wiki.haskell.org/Monad_laws[monad laws]:

1. The _unit_ function is a _left-identity_ for _bind_:
+
[source,typescript]
----
let f: (value: T) => Maybe<U>;

maybe(x).onto(f) === f(x);
----
+
Given a function `f` mapping a `value` to a `Maybe`
and applying it using the `onto` operator,
the result will be the same as applying this function `f` directly.
+
2. The _unit_ function is a _right-identity_ for _bind_:
+
[source,typescript]
----
let ma: Maybe<T>;

ma.onto(maybe) === ma;
----
+
Given a monad value,
applying a unit function through the `onto` operator
results in the same monad value.
+
3. _Bind_ operator is associative
+
[source,typescript]
----
let ma: Maybe<T>;
let f: (value: T) => Maybe<U>;
let g: (value: U) => Maybe<V>;

ma.onto(a => f(a).onto(g)) === ma.onto(f).onto(g)
----
+
Given a monad value,
applying one function and then another inside one `onto`
is the same as applying those functions one after another.
In other words, `onto` operators can be flattened.

[WARNING]
====
If you have a `flatMap` function with custom handling for `null` or `undefined` values,
you may break the _left-identity_ and the _associativity_ monad laws.
====

.Custom handling of `null` with `Maybe<T>.onto()` breaking the _left-identity_ law.
[source,typescript]
----
import { isNull } from '@perfective/common';
import { Just, just, naught } from '@perfective/common/maybe';

function decimal(value: number | null): Just<string> { // <.>
    if (isNull(value)) {
        return just('0');
    }
    return just(value.toString(10));
}

just(3.14).onto(decimal) == decimal(3.14); // <.>
naught().onto(decimal) != decimal(null); // <.>
----
<.> `Maybe<T>.onto()` expects the function of type `Unary<number, Maybe<string>>`,
but the `decimal` function is of type `Unary<number | null, Maybe<string>>`,
so the argument type does not match.
<.> Applying `decimal` to a present `number` behaves as expected.
<.> When the value is absent, `onto` does not execute `decimal` at all,
so the result is not the same as applying `decimal` directly.

If you have to use custom handling of `null`/`undefined`,
you should use `Optional<T>` or `Nullable<T>` types
that treat `null` and `undefined` as present values.

.Custom handling of `null` with `Optional<T>.onto()` satisfying the _left-identity_ law.
[source,typescript]
----
import { isNull } from '@perfective/common';
import { Some, some, none } from '@perfective/common/maybe';

function decimal(value: number | null): Some<string> { // <.>
    if (isNull(value)) {
        return just('0');
    }
    return just(value.toString(10));
}

some(3.14).onto(decimal) == decimal(3.14); // <.>
none().onto(decimal) == decimal(null); // <.>
----
<.> `Optional<T>.onto()` expects the function of type `Unary<number | null, Optional<string>>`,
and the `decimal` function is of type `Unary<number | null, Some<string>>`,
so the argument type matches.
<.> Applying `decimal` to a present `number` behaves as expected.
<.> When the value is `null`, `Optional<T>` considers it as present and runs `onto(decimal)`,
so the result is the same as applying `decimal` directly.

For the (legacy) functions
(written prior to using `Maybe`)
that handle/return `null`/`undefined`,
you should use `Maybe.map()` or `Maybe.lift()` methods.

[INFO]
====
This method is similar to the `mergeMap`/`switchMap` operator in `rxjs`
and the `flatMap` method in `java.util.Optional`.
====


=== `to(map)`

`Maybe.to()` is a mapping operator
that applies a provided mapping function only when the value is present
and wraps up the result into a new `Maybe` value.
`Maybe.to()` is the `fmap` operator and satisfies https://wiki.haskell.org/Functor[functor laws]:

1. `Maybe.to` preserves identity morphisms:
+
[source,typescript]
----
import { maybe } from '@perfective/common/maybe';

// fmap id = id
maybe(3.14).to(x => x) === maybe(3.14);
----
+
When the value in the Maybe is mapped to itself, the result is the same Maybe.
+
2. `Maybe.to` preserves composition of morphisms:
+
[source,typescript]
----
import { maybe, naught, nothing } from '@perfective/common/maybe';
import { decimal } from '@perfective/number';
import { split } from '@perfective/string';

// fmap f . fmap g == fmap (f . g)
maybe(3.14).to<string>(decimal).to(split('.'))
    === maybe(3.14).to(x => split('.')(decimal(x)));
----
+
Two `Maybe.to()` operations applied one after another using two functions return the same result
as applying `Maybe.to()` once with the composition of the same two functions.

[IMPORTANT]
====
`Maybe.to` is not the _bind_ (`>>=`) operator and is not required to satisfy the monad laws.
====

.Using `Maybe.to()` chaining
[source,typescript]
----
import { Maybe, maybe } from '@perfective/common/maybe';
import { lowercase } from '@perfective/common/string';

interface Name {
    first: string;
    last: string;
}

interface User {
    name?: Name;
}

function nameOutput(name: Name): string { // <.>
    return `${name.first} ${name.last}`;
}

function usernameOutput(user?: User): Maybe<string> {
    return maybe(user)
        .pick('name')
        .to(nameOutput)
        .to(lowercase);
}
----
<.> The `to` method wraps the result into `maybe`.

[INFO]
====
This method is similar to the `map` operator in `rxjs`
and the `map` method in `java.util.Optional`.
====


=== `into(fold)`

`Maybe.into()` is a fold (reduce) operator for the `Maybe` type.
It applies the given `fold` function to the `value` of the `Maybe`
and returns the result of any type as is.
The purpose of `Maybe.into()` is to terminate the `Maybe`
and switch to a different type.

[NOTE]
====
Unlike `Maybe.onto()` and `Maybe.to()`,
the `Maybe.into()` method is called even if the `Maybe.value` is absent.

Unlike `Maybe.or()` and `Maybe.otherwise()`,
the `Maybe.into()` method is called even if the `Maybe.value` is present.
====

.Using `Maybe.into()`
[source,typescript]
----
import { Maybe, maybe } from '@perfective/common/maybe';
import { isPresent } from '@perfective/common';

function usernameRequest(userId: number | null | undefined): Promise<string> {
    if (isPresent(userId)) {
        return Promise.resolve({ userId });
    }
    return Promise.reject("UserId is missing");
}

function username(userId: Maybe<number>): Promise<string> {
    return userId.into(usernameRequest) // === usernameRequest(userId.value)
        .then(response => response.username) // <.>
        .catch(() => "Unknown");
}
----
<.> While applying the function directly is possible,
the `Maybe.into()` method allows to switch the chain to a different monadic type
and continue the chain with that new type.


=== `pick(property)`

`Maybe.pick()` is a shortcut for the `Maybe.to()`
that picks a property value by its name.
Only properties that are defined on the value type are allowed.

It is similar to the
https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#optional-chaining[optional chaining]
introduced in TypeScript 3.7
but does not generate excessive JS code for each `null` and `undefined` check in the chain.

.Using `Maybe.pick()` for optional chaining
[source,typescript]
----
import { panic } from '@perfective/common/error';
import { maybe } from '@perfective/common/maybe';

interface Name {
    first?: string;
    last?: string;
}

interface User {
    id: number;
    name?: Name;
}

function firstName(user?: User): string {
    return maybe(user).pick('name').pick('first').or(panic('Unknown first name')); // <.>
}

function userId(user: User): number {
    return just(user).pick('id').value; // <.>
}
----
<.> `maybe(user).pick('email')` will not compile,
as, in this example, the `User` type does not have an `email` property.
<.> When the value is `Just<T>`, and you `pick` a required property,
the result is `Just<U>` (where `U` is the type of that property).
Hence, starting a `maybe`-chain with `Just` is strongly recommended
if the value is already present.

[INFO]
====
This method is similar to the `pluck` operator in `rxjs`.
====


=== `that(filter)`

`Maybe.that()` is a filter method.
It allows passing a predicate for filtering a present value.

.Using `Maybe.that()` to filter out a value
[source,typescript]
----
import { isNot } from '@perfective/common/function';
import { Maybe, just } from '@perfective/common/maybe';

function quotient(dividend: number, divisor: number): Maybe<number> {
    return just(divisor)
        .that(isNot(0)) // <.>
        .to(divisor => dividend / divisor);
}
----
<.> Returns `Nothing`, so `to()` will not be running its function.

[INFO]
====
This method is similar to the `filter` operator in `rxjs`
and the `filter` method in `java.util.Optional`.
====


=== `which(filter)`

`Maybe.which()` is a filter method that requires passing a
link:https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types[_type guard_].
It narrows down the result type based on the type guard.

.Using `Maybe.which()` to filter out values with absent properties.
[source,typescript]
----
import { Maybe, just } from '@perfective/common/maybe';
import { hasDefinedProperty } from '@perfective/common/object';

interface Name {
    first: string;
    last: string;
}

interface Username {
    first?: string;
    middle?: string;
    last?: string;
}

function nameOutput(name: Name): string {
    return `${name.first} ${name.last}`;
}

function usernameOutput(user: User): Maybe<string> {
    return just(user)
        .which(hasDefinedProperty('first', 'last')) // <.>
        .to(nameOutput); // <.>
}
----
<.> A broader `hasPresentProperty('first', 'last')` can also be used.
to guarantee that these properties' values are not `null` too.
But it is not required by the TS compiler `strictNullCheck`,
as these properties are _optional_, not _nullable_.
<.> `Name` type requires both `first` and `last` properties to be defined and not null,
so  without the `which` filter (with TS `strictNullChecks` enabled),
this code will not compile.


=== `when(condition)`

`Maybe.when()` is a filter method.
It uses a proposition
(a `boolean` value or a nullary function that returns a `boolean` value)
to describe a condition that is not related to the value inside `Maybe`.

[NOTE]
====
`Maybe.when()` should be used for better readability
instead of passing a nullary function into the `Maybe.that()`.
====

.Using `Maybe.when()` to filter out values based on a global condition.
[source,typescript]
----
import { just } from '@perfective/common/maybe';

function tokenLogOutput(token: string, isLog: boolean): Maybe<string> {
    return just(token)
        .when(isLog) // <.>
        .to(token => '***');
}
----
<.> You can use `when(() => isLog)`
if you only want to run the computation when the value is present.


=== `otherwise(fallback)`

`Maybe.otherwise()` method allows passing a fallback value or throwing an error
if the monad value is _absent_.

.Using `Maybe.otherwise()` to continue the chain after the fallback.
[source,typescript]
----
import { panic } from '@perfective/common/error';
import { isNot } from '@perfective/common/function';
import { maybe } from '@perfective/common/maybe';

function range(min?: number, max?: number): number {
    return maybe(min)
        .otherwise(max) // <.>
        .that(isNot(0))
        .otherwise(panic('Invalid range'));
}
----
<.> `otherwise` wraps the fallback value into the next `Maybe`.


=== `or(fallback)`

The `Maybe.or()` method allows getting the present monad value
and providing a fallback value or throwing an error
when the monad value is missing.

.Using `Maybe.or()`
[source,typescript]
----
import { panic } from '@perfective/common/error';
import { maybe } from '@perfective/common/maybe';

interface Name {
    first: string;
    last: string;
}

interface User {
    name?: Name;
}

function nameOutput(name?: Name): string {
    return maybe(name)
        .to(name => `${name.first} ${name.last}`)
        .or('Unknown name'); // <.>
}

function userOutput(user?: User): string {
    return maybe(user)
        .pick('name')
        .to(nameOutput)
        .or(panic('Undefined user')); // <.>
}
----
<.> The fallback value type can be present or absent.
It allows returning only `undefined` or `null` if the value is absent.
<.> Using `panic` or any other function that throws an error when called
allows guaranteeing a present value is returned.

[INFO]
====
This method is similar to the `orElse`, `orElseGet`, and `orElseThrow` methods in `java.util.Optional`.
====


=== `run(procedure)`

The `Maybe.run()` method allows executing a procedure using the present value.
`Maybe.run()` discards the procedure's return value
and keeps the original monad value.

[WARNING]
====
The `Maybe.run()` does not check if the given procedure mutates the present value.
====

[source,typescript]
----
import { optional } from '@perfective/common/maybe';

function logError(error?: Error): Error|undefined {
    return optional(error)
        .run(console.error);
}
----

[NOTE]
====
This method is similar to the `tap` operator in `rxjs`
and `ifPresent` method in `java.util.Optional`.
====


=== `lift(map)`

The `Maybe.lift()` method allows passing a function that maps even an absent value.
Unlike `Maybe.map()`, which is called only when the value is present,
the `Maybe.lift()` method always runs.

[source,typescript]
----
import { isAbsent } from '@perfective/common';
import { maybe } from '@perfective/common/maybe';

function decimal(value?: number | null): string {
    if (isAbsent(value)) {
        return '0';
    }
    return value.toString(10);
}

maybe(undefined).lift(decimal) === just(decimal(undefined));
maybe(null).lift(decimal) === just(decimal(null)); // <.>
----
<.> `Maybe.lift()` wraps the result into the next `maybe` value.


=== Lifting functions

Each method has a corresponding lifting function to be used in the `Array.prototype.map`
(or any other mapping method or operator).

[source,typescript]
----
import { Maybe, just, naught, nothing, or } from '@perfective/common/maybe';

const numbers: Maybe<number>[] = [
    just(2.71),
    just(3.14),
    nothing<number>(),
    naught<number>(),
];

numbers.map(or(0)) === [2.71, 3.14, 0, 0];
----

[WARNING]
====
As of v0.6.0, the lifting functions are only supported for the `Maybe`/`Just`/`Nothing` types
and not for `Nullable`/`Only`/`Nil` or `Optional`/`Some`/`None`.
====
