= String
:mdn-js-globals: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects

The `@perfective/common/string` package works with the standard JS
`link:{mdn-js-globals}/String[String]` type.
It provides the following functions and additional types.

* Unit functions:
** `lines(value: string): string[]`
— splits a given string into an array of string based on the line separator (`\n`, `\r\n\`, and `\r`).
+
* Type guards:
** `isString<T>(value: T | string): value is string`
** `isNotString<T>(value: T | string): value is T`
+
* Predicates:
** `isEmpty(value: string): boolean`
** `isNotEmpty(value: string): boolean`
** `includes(search: string, position?: number): Unary<string, boolean>`
** `endsWith(search: string, length?: number): Unary<string, boolean>`
** `startsWith(search: string, from: number = 0): Unary<string, boolean>`
+
* Properties:
** `length(value: string): number`
+
* Operators:
** `charAt(index: number): Unary<string, string>`
** `concat(...strings: string[]): Unary<string, string>`
** `concatTo(value: string): Unary<string | string[], string>`
** `lowerCase(value: string): string`
** `padEnd(length: number, fill?: string): Unary<string, string>`
** `padStart(length: number, fill?: string): Unary<string, string>`
** `repeat(count: number): Unary<string, string>`
** `replace(search: string | RegExp, replacement: string): Unary<string, string>`
** `replaceWith(search: string | RegExp, replacement: Replacement): Unary<string, string>`
** `slice(start: number, end?: number): Unary<string, string>`
** `split(separator: string | RegExp, limit?: number): Unary<string, string[]>`
** `trim(value: string): string`
** `upperCase(value: string): string`
+
* Search functions:
** `indexOf(search: string, from: number = 0): Unary<string, number>`
** `lastIndexOf(search: string, from?: number): Unary<string, number>`
** `search(search: RegExp): Unary<string, number | -1>`
+
* `Utf16CodeUnit`:
** `stringFromCharCode(...codes: Utf16CodeUnit[]): string`
** `charCodeAt(index: number): Unary<string, Utf16CodeUnit>`
+
* `CodePoint`:
** `stringFromCodePoint(...codePoints: CodePoint[]): string`
** `codePointAt(position: number): Unary<string, CodePoint | undefined>`
+
* `UnicodeNormalizationForm`:
** `normalize(form: UnicodeNormalizationForm = 'NFC'): Unary<string, string>`


== Format

* `Format`
— represents a template with tokens that can be turned into a string.
** `format(template: string, tokens: Tokens | unknown[] = {}): Format`
— creates a {@link Format} record with the given `template` and `tokens`.
** `formatted(input: Format): string`
— replaces `Format.tokens` in the `Format.template` and returns the resulting string.
+
Each token is wrapped in the double curly braces.
For example, a template with a token `{\{foo}}` will be replaced by the string value of the token `foo`.
+
* `Tokens`:
— a mapping between a token and its string value.
** `tokens(tokens: unknown[] | Tokens): Tokens`
— creates `Tokens` record from a given array of positional tokens,
where each token is an index of each value in the given array.
+
If given a `Tokens` object returns the given object.


== Roadmap

* Implement with the `@perfective/common/locale` package:
** `link:{mdn-js-globals}/String/localeCompare[String.prototype.localeCompare]`;
** `link:{mdn-js-globals}/String/toLocaleLowerCase[String.prototype.toLocaleLowerCase]`;
** `link:{mdn-js-globals}/String/toLocaleUpperCase[String.prototype.toLocaleUpperCase]`.
* Implement with the `@perfective/common/regexp` package:
** `link:{mdn-js-globals}/String/match[String.prototype.match]`;
** `link:{mdn-js-globals}/String/matchAll[String.prototype.matchAll]`;
* Implement with a polyfill:
** `link:{mdn-js-globals}/String/trimEnd[String.prototype.trimEnd]`;
** `link:{mdn-js-globals}/String/trimEnd[String.prototype.trimStart]`.
