= Perfective Common for TypeScript


== Installation

[source,bash]
----
npm install @perfective/common
----


== Key Features

The `@perfective/common` package facilitates writing highly readable functional code.
It focuses on providing functions to handle ECMAScript types
and to easily compose functions together.


=== Maybe monad

The `link:https://github.com/perfective/ts.common/tree/main/src/maybe/index.adoc[@perfective/common/maybe]` package
provides a Maybe monad implementation.

It allows you to write and compose functions that accept only present (defined and non-null) values
It helps to avoid additional complexity and noise of handling `null` and `undefined` values.

For example, consider you have the `User` and `Name` types below,
and you want to output a user's full name.

[source,typescript]
----
interface User {
    name?: Name;
}

interface Name {
    first: string;
    last: string;
}
----

If you write functions that have to handle `null` and `undefined` values,
then you would have to write something like:

[source,typescript]
----
import { isPresent } from '@perfective/common';
import { isNotEmpty } from '@perfective/common/string';

function userNameOutput(user: User | null | undefined): string {
    if (isPresent(user)) {
        const name = fullName(user.name);
        if (isPresent(name)) {
            return name;
        }
    }
    throw new Error('User name is unknown');
}

function fullName(name: Name | null | undefined): string | null {
    if (isPresent(name)) {
        const name = `${name.first} ${name.last}`.trim();
        if (isNotEmpty(name)) {
            return name;
        }
    }
    return null;
}
----

When using the `link:https://github.com/perfective/ts.common/tree/main/src/maybe/index.adoc[Maybe]` monad you can write
simpler and more readable functions:

[source,typescript]
----
import { panic } from '@perfective/common/error';
import { just, maybe } from '@perfective/common/maybe';
import { isNotEmpty, trim } from '@perfective/common/string';

function userNameOutput(user: User | null | undefined): string {
    return maybe(user)
        .pick('name') // <.>
        .onto(fullName) // <.>
        .or(panic('User name is unknown')); // <.>
}

function fullName(name: Name): Maybe<string> {
    return just(`${name.first} ${name.last}`)
        .to(trim) // <.>
        .that(isNotEmpty); // <.>
}
----
<.> `link:https://github.com/perfective/ts.common/blob/main/src/maybe/index.adoc#maybepick[Maybe.pick()]`
provides a strictly-typed "optional chaining" of the `Maybe.value` properties.
<.> `link:https://github.com/perfective/ts.common/blob/main/src/maybe/index.adoc#maybeonto[Maybe.onto()]`
(flat) maps a `Maybe.value` to another `Maybe`.
<.> `https://github.com/perfective/ts.common/blob/main/src/maybe/index.adoc#maybeor[Maybe.or()]`
extracts a `value` from the `Maybe` with a given fallback.
(or allows to throw an error).
<.> `link:https://github.com/perfective/ts.common/blob/main/src/maybe/index.adoc#maybethat[Maybe.that()]`
filters a value inside `Maybe`.
<.> `link:https://github.com/perfective/ts.common/blob/main/src/maybe/index.adoc#maybeto[Maybe.to()]` maps a value inside `Maybe` using a given callback.

In addition to these methods,
the `link:https://github.com/perfective/ts.common/tree/main/src/maybe/index.adoc[Maybe]` type also provides:
`link:https://github.com/perfective/ts.common/blob/main/src/maybe/index.adoc#maybeinto[Maybe.into()]`,
`link:https://github.com/perfective/ts.common/blob/main/src/maybe/index.adoc#maybewhich[Maybe.which()]`,
`link:https://github.com/perfective/ts.common/blob/main/src/maybe/index.adoc#maybewhen[Maybe.when()]`,
`link:https://github.com/perfective/ts.common/blob/main/src/maybe/index.adoc#maybeotherwise[Maybe.otherwise()]`,
and `link:https://github.com/perfective/ts.common/blob/main/src/maybe/index.adoc#maybethrough[Maybe.through()]` methods.


=== Result monad

The `@perfective/common/result` package provides a Result monad
(a concrete case of an Either monad).
It allows you to treat errors as part of function result
and chain processing of such results.

For example,
consider you are writing a function that loads a backend entity based on the user input.

.Example of the provided functions and types.
[source,typescript]
----
interface Request {
    entity: string;
    id: number;
}

interface User {
    id: number;
    username: string;
}

/**
 * @throws {Error} If a given input is empty or is not a number.
 */
declare function numberInput(input: string): number;

declare function request(entity: string): (id: number) => Request;

declare function user(request: Request): User;
----

Writing an imperative code you would have:

[source,typescript]
----
function userOutput(input: string): User {
    let id: number;
    try {
        id = numberInput(input);
    } catch (error: Error) {
        id = 0;
    }
    const userRequest = request('user');
    return user(userRequest(id));
}
----

Using the `Result` your code would be:

[source,typescript]
----
import { recovery, Result, resultOf } from '@perfective/common/result';

function userOutput(id: string): Result<User> {
    return resultOf(() => numberInput(id))
        .into(recovery(0))
        .to(request('user'))
        .to(user);
}
----

The `Result` link:https://github.com/perfective/ts.common/blob/main/src/result/index.adoc#using-result-with-promise[integrates]
with the `Promise` using the `promisedResult()` and `settledResult()` functions.


=== Chained Exceptions

The ECMA `link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/Error[Error]` class does not store a previous error.
This is inconvenient, as it requires either manually add previous error message to a new error.
Or worse, skip providing previous error altogether.

Chaining previous errors is helpful for debugging.
Especially in async environments, when most of the stack trace is full of useless functions calls like `next()`
or on the frontend with packed code and renamed functions.

To make logging and debugging of productions code easier,
the `link:https://github.com/perfective/ts.common/tree/main/src/error/index.adoc[@perfective/common/error]` package provides the `Exception` class.
It supports three features:

* providing a previous error (allows to stack errors);
* using a message template with string tokens (allows to localize and format messages);
* storing additional context (simplifies logging and debugging).

.Using the `Exception` class and its constructors.
[source,typescript]
----
import { causedBy, chained, exception } from '@perfective/common/error`

function numberInput(input: string): number {
    const id = Number(input);
    if (Number.isNaN(id)) {
        throw exception('Input {{value}} is not a number', { // <.>
            value: input,
        });
    }
    return id;
}

function userRequest(id: string): Request {
    try {
        const userId = numberInput(id);
        return {
            method: 'GET',
            url: `user/${userId}`,
        };
    } catch (error: Error) {
        throw causedBy(error, 'Invalid user id {{id}}', { // <.>
            id,
        });
    }
}

async function userResponse(request: Request): Promise<User> {
    return fetch(request.url, {
        method: request.method,
    });
}

function user(id: string): Promise<User> {
    return Promise.resolve(id)
        .then(userRequest)
        .then(userResponse)
        .catch(chained('Failed to load user {{id}}', { // <.>
            id,
        }));
}
----
<.> Use `exception()` to instantiate an initial `Exception` without previous errors.
<.> When you use a `try-catch` block,
use the `causedBy()` function to create an `Exception` with a previous error.
<.> Use the `chained()` function,
when you need to create a callback to chain an `Error`
(for example, in `Promise` or in a `Result`).


When you want to output a chained `Exception`,
you can use the `Exception.toString()` method.
For the example above, the output may look like:

[source,text]
----
Exception: Failed to load user `A`
    - Exception: Invalid user id `A`
    - Exception: Input `A` is not a number
----

If you want to log an `Exception` for debugging purposes,
you can use the `chainedStack()` function.
It will return a similar chain of messages as above,
but each message will also contain a stack trace for each error.

Read more about the functions to handle the built-in JS errors and the `Exception` class in the
`link:https://github.com/perfective/ts.common/tree/main/src/error/index.adoc[@perfective/common/error]` package docs.


== Packages

Packages are organized and named around their primary type:

* `link:https://github.com/perfective/ts.common/blob/main/src/value/index.adoc[@perfective/common]`
— functions and types to handle types (e.g., `TypeGuard` interface), `null`, `undefined`, and `void` values.
+
* `link:https://github.com/perfective/ts.common/tree/main/src/array/index.adoc[@perfective/common/array]`
— functions and types to handle
link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array[arrays].
+
* `link:https://github.com/perfective/ts.common/tree/main/src/boolean/index.adoc[@perfective/common/boolean]`
— functions and types to handle
`link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean[boolean]` values.
+
* `link:https://github.com/perfective/ts.common/tree/main/src/error/index.adoc[@perfective/common/error]`
— functions and types to handle
`link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error[Error]`
and related classes.
+
* `link:https://github.com/perfective/ts.common/tree/main/src/function/index.adoc[@perfective/common/function]`
— functions and types for functional programming.
+
* `link:https://github.com/perfective/ts.common/tree/main/src/match/index.adoc[@perfective/common/match]`
— functions and types for a functional style `switch-case`.
+
* `link:https://github.com/perfective/ts.common/tree/main/src/maybe/index.adoc[@perfective/common/maybe]`
— a `Maybe` monad (https://en.wikipedia.org/wiki/Option_type[Option type]) implementation.
+
* `link:https://github.com/perfective/ts.common/tree/main/src/number/index.adoc[@perfective/common/number]`
— functions and types to handle
link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number[numbers].
+
* `link:https://github.com/perfective/ts.common/tree/main/src/object/index.adoc[@perfective/common/object]`
— functions and types to handle the
`link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object[Object]` class.
* `link:https://github.com/perfective/ts.common/tree/main/src/number/index.adoc[@perfective/common/promise]`
— functions and types to handle the
`link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise[Promise]` class.
+
* `link:https://github.com/perfective/ts.common/tree/main/src/result/index.adoc[@perfective/common/result]`
— a `Result` monad (https://en.wikipedia.org/wiki/Result_type[Result type]) implementation.
* `link:https://github.com/perfective/ts.common/tree/main/src/string/index.adoc[@perfective/common/string]`
— functions and types to handle
link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String[strings].

The packages have full unit tests coverage.

[IMPORTANT]
====
The code provided by this project relies on the strict https://www.typescriptlang.org[TypeScript] compiler checks.
Use of these packages in the regular JS projects may produce unexpected behavior and is undocumented.
For example,
a function that declares an argument as _required_ relies on strict TSC `null` checks
and does not check value for `null` additionally.
====
