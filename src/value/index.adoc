= Common

The `@perfective/common` package provides functions to work with `undefined` and `null` values,
utility types to work with `undefined` and `null`
(similar to `link:https://www.typescriptlang.org/docs/handbook/utility-types.html#nonnullablet[NonNullable<T>]`).
It also provides functions to work with type and instance definitions.


== Value

* `type Defined<T> = T extends undefined ? never : T`:
** `isDefined<T>(value: T | undefined): value is T`;
+
* `type Undefined<T> = T extends undefined ? T : never`:
** `isUndefined<T>(value: T | undefined): value is undefined`;
+
* `type NotNull<T> = T extends null ? never : T`:
** `isNotNull<T>(value: T | null): value is T`;
+
* `type Null<T> = T extends null ? T : never`:
** `isNull<T>(value: T | null): value is null`;
+
* `type Present<T> = T extends null | undefined ? never : T`:
— same as `NonNullable<T>`, but is used in the project for consistency with the type guards;
** `isPresent<T>(value: T | null | undefined): value is T`;
+
* `type Absent<T> = T extends null | undefined ? T : never`:
** `isAbsent<T>(value: T | null | undefined): value is null | undefined`.

[NOTE]
====
`isDefined` and `isUndefined` use the same check against `void 0`
as the JS code generated by TypeScript for the
https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining[optional chaining],
while TS compiler keeps checks `typeof value === 'undefined'` and `value === undefined` as is.
====


== Type and Instance

* `TypeGuard<T, V extends T> = (value: T) => value is V`
— a function type to check if the value is of a certain type.
+
* `Instance<T> = new(...args: any[]) => T`
— definition for a type reference:
** `isInstanceOf<T, V = unknown>(type: Instance<T>): (value: T | V) => value is T`
** `isNotInstanceOf<T, V = unknown>(type: Instance<T>): (value: T | V) => value is V`

[WARNING]
====
The `isInstanceOf`/`isNotInstanceOf` functions generic parameters
are not always correctly recognized by the compiler.
It works as expected for the concrete classes,
but requires explicit type parameter for the TypeScript classes.

[source,typescript]
----
import { isInstanceOf } from '@perfective/common/function';


class A { public readonly value: string = 'a'; }
class B extends A {}
class C { public readonly c: string = 'value'; }

let x: A | C = new B();

if (isInstanceOf(A)(x)) { // <.>
    x.value; // <.>
}

let xOrError: A | TypeError = new TypeError();
if (isInstanceOf<TypeError>(TypeError)(xOrError)) { // <.>
}

let typeOrRangeError: TypeError | RangeError = new RangeError();
if (isInstanceOf<TypeError>(TypeError)(typeOrRangeError)) { // <.>
}

----
<1> `isInstanceOf` infers class `A` as the type parameter.
<2> Compiler type guards `x` as an instance of `A`.
<3> Explicitly providing the built-in type.
Otherwise, compiler considers `xOrError` as `A | TypeError`.
The function works correctly.
<4> For the union of two built-in type,
even explicit type parameter does not work.
The function works correctly.
====


== ECMA and TypeScript types

JavaScript provides the `typeof` operator that returns 'object' for arrays and `null`.
This results in additional checks needed using this operator.
To reduce this complexity, the `typeOf<T>` function is provided with the conditional `TypeOf<T>` type.

* Types
** `EcmaType`
— is one of `undefined`, `boolean`, `number`, `bigint`, `string`, `symbol`, `function`, or `object`.
** `TsType`
— is one of `EcmaType` or `null`, `array`, and `unknown`.
** `TypeOf<T>`
— a conditional type that returns `TsType` dynamically.
+
* Unit functions:
** `ecmaType(type: EcmaType): EcmaType`
— Type guards an `EcmaType` value in compile time
(unlike the `as` operator which allows to type cast any string as `EcmaType`).
Throws a `TypeError` when the value in runtime is not an `EcmaType`.
** `typeOf<T>(value: T | null | undefined): TypeOf<T> & TsType`.
+
* Type guards:
** `isEcmaType(input: string): input is EcmaType`
— returns true and narrows the variable type, if the given input string is an `EcmaType`.
+
* Predicates:
** `isTypeOf<T>(type: TypeOf): (value: T | null | undefined) => boolean`;
** `isNotTypeOf<T>(type: TypeOf): (value: T | null | undefined) => boolean`.


== Handling `void`

In TypeScript, `link:https://www.typescriptlang.org/docs/handbook/basic-types.html#void[void]` type
is treated differently from `undefined` and `null`,
and linters provide different rules to restrict its usage only to correct cases.

Unfortunately, different packages (like AWS SDK) may use `void` as a synonym to `null | undefined`.
This approach creates conflicts in the code linted with the
`link:https://github.com/perfective/eslint-config[@perfective/eslint-config]`,
so a special function is introduced to "type cast" any `void` value into `null | undefined`:

* `voidable<T>(value: T | void): T | null | undefined`
