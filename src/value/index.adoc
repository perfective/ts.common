= Value

The `@perfective/common/value` package provides functions to work with `undefined` and `null` values
and utility types
(similar to `link:https://www.typescriptlang.org/docs/handbook/utility-types.html#nonnullablet[NonNullable<T>]`)
to describe some of such values.

== Utility types

* `type Defined<T> = T extends undefined ? never : T`;
* `type Undefined<T> = T extends undefined ? T : never`;
* `type NotNull<T> = T extends null ? never : T`;
* `type Null<T> = T extends null ? T : never`;
* `type Present<T> = T extends null | undefined ? never : T`
— same as `NonNullable<T>`, but is used in the project for consistency with the type guards;
* `type Absent<T> = T extends null | undefined ? T : never`.


== Type Guards

* `isDefined<T>(value: T | undefined): value is T`;
* `isUndefined<T>(value: T | undefined): value is undefined`;
* `isNotNull<T>(value: T | null): value is T`;
* `isNull<T>(value: T | null): value is null`;
* `isPresent<T>(value: T | null | undefined): value is T`;
* `isAbsent<T>(value: T | null | undefined): value is null | undefined`.

[NOTE]
====
`isDefined` and `isUndefined` use the same check against `void 0`
as the JS code generated by TypeScript for the
https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining[optional chaining],
while TS compiler keeps checks `typeof value === 'undefined'` and `value === undefined` as is.
====


== ECMA and TypeScript types

JavaScript provides the `typeof` operator that returns 'object' for arrays and `null`.
This results in additional checks needed using this operator.
To reduce this complexity, the `typeOf<T>` function is provided with the conditional `TypeOf<T>` type.

* Types
** `EcmaType`
— is one of `undefined`, `boolean`, `number`, `bigint`, `string`, `symbol`, `function`, or `object`.
** `TsType`
— is one of `EcmaType` or `null`, `array`, and `unknown`.
** `TypeOf<T>`
— a conditional type that returns `TsType` dynamically.
+
* Unit function:
** `typeOf<T>(value: T | null | undefined): TypeOf<T> & TsType`.
+
* Predicates:
** `isTypeOf<T>(type: TypeOf): (value: T | null | undefined) => boolean`;
** `isNotTypeOf<T>(type: TypeOf): (value: T | null | undefined) => boolean`.


== Handling `void`

In TypeScript, `link:https://www.typescriptlang.org/docs/handbook/basic-types.html#void[void]` type
is treated differently from `undefined` and `null`,
and linters provide different rules to restrict its usage only to correct cases.

Unfortunately, different packages (like AWS SDK) may use `void` as a synonym to `null | undefined`.
This approach creates conflicts in the code linted with the
`link:https://github.com/perfective/eslint-config[@perfective/eslint-config]`,
so a special function is introduced to "type cast" any `void` value into `null | undefined`:

* `voidable<T>(value: T | void): T | null | undefined`
