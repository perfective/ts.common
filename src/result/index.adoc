= Result

The `@perfective/common/result` package provides
a https://en.wikipedia.org/wiki/Result_type[Result type] implementation.

The `Result` type represents a result of a function that can be a `Success` or a `Failure` (an `Error`).
It provides a mechanism for "checked exceptions"
and allows to avoid `try-catch` blocks and unchecked JavaScript errors.


== Using `Result` with `Promise`

You can use `Result<T>` to handle synchronous parts of `Promise` chains.

[source,typescript]
----
import { error, throws } from '@perfective/common/error';
import { Unary } from '@perfective/common/function';
import { failure, promisedResult, Result, settledResult, success } from '@perfective/common/result';
import { isEmpty } from '@perfective/common/string';

interface Request {
    method: string;
    url: string;
}

function validInput(id: string): string {
    if (isEmpty(id)) {
        return throws(error('Input id is empty'));
    }
    return id;
}

function apiRequest(method: string): Unary<string, Request> {
    return (id: string): Request => ({
        method,
        url: `/entity/${id}`,
    });
}

async function apiResponse(request: Request): Promise<string> {
    if (request.method === 'HEAD') {
        return '501 Not Implemented';
    }
    return '200 OK';
}

async function entityById(inputId: Promise<string>): Promise<string> {
    return inputId
        .then(validInput)
        .then(apiRequest('HEAD')) // <.>
        .then(apiResponse);
}

async function entityById(inputId: Promise<string>): Promise<string> {
    return promisedResult(inputId) // <.>
        .then(headApiRequest) // <.>
        .then(settledResult) // <.>
        .then(apiResponse);
}

async function headApiRequest(inputId: Result<string>): Result<Request> {
    return inputId.onto(validId).to(apiRequest('HEAD'));
}

function validId(id: string): Result<string> {
    if (isEmpty(id)) {
        return failure(error('Input id is empty'));
    }
    return success(id);
}
----
<.> Even if the `inputId` is a `Promise`,
and the `apiResponse` is an asynchronous function,
the `validInput` and `apiRequest` functions are synchronous.
<.> Use `promisedResult` to wrap `Promise` resolved value or rejection into a `Result`.
<.> The result is transformed using a synchronous `headApiRequest` function.
<.> Use `settledResult` to unpack a `Result` into a settled `Promise`.
In this case, if the value is a `Success`, a fulfilled `Promise` is returned.
But if the value is a `Failure`,
then a `Promise` is rejected.


== Reference

=== Functions

* `success<T>(value: T): Success<T>`
— creates a `Success` object from a given `value`.
It is a _unit_ function for the `Result` monad.
+
[NOTE]
====
An `Error` type can also be used as a `Success` value.

For example, when an API returns an error code
and this error code is parsed and matched to a specific `Error` subtype.
====
+
* `successFrom<T, U>(map: (value: T) => U): Unary<T, Success<U>>`
— creates a function to transform a `value` with a given `map` callback
and return the result as a `Success`.
+
* `failure<T>(error: Error): Failure<T>`
— creates a `Failure` object from a given `error`.
+
Throws a `TypeError`, if the given `error` value is not an `Error` object.
+
* `failureFrom<T>(map: (value: T) => Error): Unary<T, Failure<T>>`
— creates a function to transform a `value` into an `Error` with a given `map` callback
and return the result as a `Failure`.
+
* `rejection<T = never>(reason: unknown): Failure<T>`
— creates a `Failure` from an `unknown` `reason`.
Pass `rejection` into `Promise.catch()` or `Promise.then()` as an `onRejected` callback
to wrap a `reason` into a `Failure`.
+
* `result<T>(value: T | Error): Result<T>`
— creates a `Failure` if a given value is an `Error`,
otherwise creates a `Success`.
+
[WARNING]
====
TypeScript compiler does not exclude an `Error` type from the `T` automatically.

If you pass a `value` of type `T | Error` to the `result()`,
the return type will be `Success<T | Error>`.

You have to cast the type parameter manually
(e.g., `result<string>(...)`)
to get the return type as `Result<T>`.
====
+
* `resultOf<T>(callback: Nullary<T>): Result<T>`
— calls a given `callback` in a `try-catch` block.
If the `callback` throws an error,
catches the error and returns it as a `Failure`.
Otherwise, returns the result of the `callback` as a `Success`.
+
Use the `resultOf` to wrap up unsafe functions into a `Result`.
+
* `resultFrom<T, U>(map: (value: T) => U | Error): Unary<T, Result<U>>`
— creates a function to transform a `value` with a given `map` callback
and return the result as a `Failure`, if the result is an `Error`.
Otherwise, it returns a `Success`.
+
* `promisedResult<T>(promise: Promise<T>): Promise<Result<T>>`
— wraps a `Promise` _value_ into a `Result`.
+
* `settledResult<T>(result: Result<T>): Promise<T>`
— creates a _settled_ `Promise` from a given `Result`.
+
* `recovery<T>(fallback: Value<T>): Unary<T | Error, Success<T>>`
— creates a function that returns a given `fallback` wrapped into a `Success`
when an error is given.
+
[WARNING]
====
Even if the `T` is a type of `Error`,
the `fallback` value will be returned.
====


=== `Result.onto()`

* `Result.onto<U>(flatMap: (value: T) => Result<U>): Result<U>`:
** for a `Success`, applies a given `flatMap` callback to the `Success.value` and returns the result;
** for a `Failure`, ignores the `flatMap` callback and returns the same `Failure`.

[source,typescript]
----
import { error, typeError } from '@perfective/common/error';
import { Unary } from '@perfective/common/function';
import { Result, failure, success } from '@perfective/common/result';
import { isEmpty } from '@perfective/common/string';

interface Request {
    method: string;
    url: string;
}

interface Response {
    status: string;
}

function validInput(id: string): Result<string> {
    if (isEmpty(id)) {
        return failure(typeError('Input id is empty'));
    }
    return success(id);
}

function apiRequest(method: string): Unary<string, Result<Request>> {
    return (id: string): Result<Request> => success({
        method,
        url: `/entity/${id}`,
    });
}

function apiResponse(request: Request): Result<Response> {
    if (request.method === 'HEAD') {
        return failure(error('Not implemented'));
    }
    return success({
        status: '200 OK',
    });
}

validInput('abc')
    .onto(apiRequest('GET'))
    .onto(apiResponse)
    .value == { status: '200 OK' }; // <.>

validInput('abc')
    .onto(apiRequest('HEAD'))
    .onto(apiResponse)
    .value == error('Not implemented'); // <.>

validInput('')
    .onto(apiRequest('HEAD'))
    .onto(apiResponse)
    .value == typeError('Input id is empty'); // <.>
----
<.> When we have a valid `id` and "send" a `GET` request,
then the whole chain succeeds.
<.> When we have a valid `id` but "send" a `HEAD` request,
the `apiResponse` fails with an `Error`.
<.> When we have an invalid `id`,
neither the `apiRequest` nor `apiResponse` callbacks are called.
+
So even as a `HEAD` request,
it would fail with the earliest error in the chain
(from `validInput`).


=== `Result.to()`

* `Result.to<U>(map: (value: T) => U): Result<U>`:
** for a `Success`, applies a given `map` callback to the `Success.value` and returns the result;
** for a `Failure`, ignores the `map` callback and returns the same `Failure`.

+
[source,typescript]
----
import { error, typeError } from '@perfective/common/error';
import { Unary } from '@perfective/common/function';
import { Result, failure, success } from '@perfective/common/result';
import { isEmpty } from '@perfective/common/string';

interface Request {
    method: string;
    url: string;
}

interface Response {
    status: string;
    url: string;
}

function validInput(id: string): Result<string> {
    if (isEmpty(id)) {
        return failure(typeError('Input id is empty'));
    }
    return success(id);
}

function apiRequest(method: string): Unary<string, Request> {
    return (id: string): Request => ({
        method,
        url: `/entity/${id}`,
    });
}

function apiResponse(request: Request): Response {
    return {
        status: '200 OK',
        url: request.url,
    };
}

validInput('abc')
    .to(apiRequest('GET'))
    .to(apiResponse) // <.>
    .value == { status: '200 OK' }; // <.>

validInput('')
    .to(apiRequest('GET'))
    .to(apiResponse)
    .value == typeError('Input id is empty'); // <.>
----
<.> Both `apiRequest` and `apiResponse` transform a given value into a new one.
`Result.to` wraps them into the next `Success`.
<.> When we have a valid `id`,
then the whole chain succeeds.
<.> When we have an invalid `id`,
neither `apiRequest` nor `apiResponse` callbacks are called.
So the result is the `TypeError` returned by the `validInput`.
+
* `Result.to<U>(mapValue: (value: T) => U, mapError: (error: Error) => Error): Result<U>`
** for a `Success`, applies a given `mapValue` callback to the `Success.value` and returns the result as a `Success`;
** for a `Failure`, applies a given `mapError` callback to the `Failure.value` and returns the result as s `Failure`.

+
This method can be used to track all occurred failures by chaining them together using the `mapError`.


=== `Result.into()`

* `Result.into<U>(reduce: (value: T | Error) => U): U`
— applies a given `reduce` callback to the `Result.value` and returns the result of the `reduce`.
+
`Result.into(reduce)` is an equivalent of applying the `reduce` callback directly to the `Result.value`.
Using `Result.into(reduce)` allows you to completely switch the type
or recover from an `Error` and continue a transformation chain.
+
[source,typescript]
----
import { error, typeError } from '@perfective/common/error';
import { Unary } from '@perfective/common/function';
import { failure, recovery, Result, success } from '@perfective/common/result';
import { isEmpty } from '@perfective/common/string';

interface Request {
    method: string;
    url: string;
}

function validInput(id: string): Result<string> {
    if (isEmpty(id)) {
        return failure(typeError('Input id is empty'));
    }
    return success(id);
}

function apiRequest(method: string): Unary<string, Request> {
    return (id: string): Request => ({
        method,
        url: `/entity/${id}`,
    });
}

async function apiResponse(request: Request): Promise<string> {
    if (request.method === 'HEAD') {
        return '501 Not Implemented';
    }
    return '200 OK';
}

async function entityById(id: string): Promise<string> {
    return validInput('') // <.>
        .into(recovery('abc')) // <.>
        .to(apiRequest('HEAD'))
        .into(apiResponse) // <.>
        .catch(() => '503 Service Unavailable'); // <.>
}
----
<.> The `id` input is not valid.
<.> We use the `Result.into()` method with the `recovery` function to recover from an `Error`.
<.> When we have a `Request`,
we use `Result.into()` to switch it to the `apiResponse` `Promise`.
<.> Now we have a `Promise` chain and can continue computation.
+
+
* `Result.into<U>(reduceValue: Unary<T, U>, reduceError: Unary<Error, U>): U`
— for a `Success` applies a given `reduceValue` to the `Success.value`,
for a `Failure` applies a given `reduceError` to the `Failure.value` (`Error`).
+
`Result.into(reduceValue, reduceError)` is a strict separate handling of the `Success.value` and `Failure.value`.
It is especially useful when the `Success.value` is an `Error`.
As in this case,
the `Result.into(reduce)` call may not be able to distinguish between a `Success.value` `Error`
and a `Failure.value` `Error`.


=== `Result.failure()`

* `Result.failure(mapError: (error: Error) => Error): Result<T>`
** For a `Failure`, applies a given `mapError` callback and returns a result wrapped into a `Failure`.
** For a `Success`, ignores the `mapError` callback and returns itself.

[source,typescript]
----
import { chainedException, typeError } from '@perfective/common/error';
import { failure, Result, success } from '@perfective/common/result';
import { isEmpty } from '@perfective/common/string';

function validInput(id: string): Result<string> {
    if (isEmpty(id)) {
        return failure(typeError('Input id is empty'));
    }
    return success(id);
}

function entityByIdRequest(id: string): Result<Request> {
    return validInput(id)
        .failure(chainedException('Entity ID {{id}} is invalid' { // <.>
            id,
        }))
        .to(apiRequest('GET'));
}
----
<.> When `validInput` returns a `Failure`,
you can use `Result.failure` method to chain or otherwise transform the error.


=== `Result.run()`

* `Result.run(valueProcedure: (value: T) => void, errorProcedure?: (error: Error) => void): Result<T>`
** For a `Success`, runs a given `valueProcedure` and returns itself;
** For a `Failure`, runs a given `errorProcedure` and returns itself.

[source,typescript]
----
import { typeError } from '@perfective/common/error';
import { empty } from '@perfective/common/function';
import { failure, Result, success } from '@perfective/common/result';
import { isEmpty } from '@perfective/common/string';

function validInput(id: string): Result<string> {
    if (isEmpty(id)) {
        return failure(typeError('Input id is empty'));
    }
    return success(id);
}

function entityByIdRequest(id: string): Result<Request> {
    return validInput(id)
        .to(apiRequest('GET'))
        .run(empty, console.error); // <.>
}
----
<.> When we have a `Success`, we only run a no-op `empty` function.
But if we have a `Failure`, we log an error.
Either way, the `Result` is the same.


== Type classes

=== Monad

The `Result<T>` type is a monad that provides:

*  the `Result.onto()` method as a _bind_ (`>>=`) operator;
*  the `success()` constructor as a _unit_ (`return`) function.

It satisfies the https://wiki.haskell.org/Monad_laws[monad laws]:

1. _unit_ is a left _identity_ for _bind_:
+
[source,typescript]
----
let x: T;
let f: (value: T) => Result<T>;

success(x).onto(f) === f(x);
----
+
2. _unit_ is a right _identity_ for _bind_:
+
[source,typescript]
----
let ma: Result<T>;

ma.onto(success) === ma;
----
+
3. _bind_ is associative:
+
[source,typescript]
----
let ma: Result<T>;
let f: (value: T) => Success<U>;
let g: (value: U) => Success<V>;

ma.onto(a => f(a).onto(g)) === ma.onto(f).onto(g);
----


=== Functor

The `Result<T>` type is a functor that provides:

* the `Result.to()` method as a _fmap_ function.

It satisfies the https://wiki.haskell.org/Functor[functor laws]:

1. `Result.to()` preserves identity morphisms:
+
[source,typescript]
----
let id = (value: T) => value;
let value: T;
let error: Error;

success(value).to(id) === success(id(value));
failure(error).to(id) === failure(id(error));
----
+
2. `Result.to()` preserves composition of morphisms:
+
[source,typescript]
----
let f: (value: U) => V;
let g: (value: T) => U;
let value: T;
let error: Error;

success(value).to(v => f(g(v))) === success(value).to(g).to(f);
failure(error).to(v => f(g(v))) === failure(error).to(g).to(f); // <.>
----
<.> `Failure.to()` ignores the input and always returns itself.


=== Bifunctor

The `Result<T>` type is a bifunctor that provides:

* the `Result.to(mapValue, mapError)` method as a _bimap_ function.
* the `Result.to(mapValue)` method as a _second_ function.
* the `Result.failure(mapError)` method as a _first_ function.

Which ensures that:

1. `Result.to(mapValue, mapError)` preserves identity morphisms
+
[source,typescript]
----
let id = (value: T) => value;
let value: T;
let error: Error;

success(value).to(id, id) === success(id(value));
failure(error).to(id, id) === failure(id(error));
----
2. `Result.to(mapValue)` preserves identity morphisms
3. `Result.failure(mapError)` preserves identity morphisms
+
+
4. Applying the `bimap` function is the same as applying the `first` and `second` functions.
+
[source,typescript]
----
let f: (value: Error) => Error;
let s: (value: T) => U;
let value: T;
let error: Error;

success(value).to(s, f) === success(value).to(s).failure(f);
failure(error).to(s, f) === failure(error).to(s).failure(f);
----
