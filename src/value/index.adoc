= Common

The `@perfective/common` package provides functions to work with `undefined` and `null` values,
utility types to work with `undefined` and `null`
(similar to `link:https://www.typescriptlang.org/docs/handbook/utility-types.html#nonnullablet[NonNullable<T>]`).
It also provides functions to work with type and instance definitions.


== Value

* `type Defined<T> = T extends undefined ? never : T`
— constructs a type by excluding `undefined` from `T`.
+
** `defined<T>(value: T | undefined): T`
— returns a given `value`, if it is defined.
Throws a `TypeError` otherwise.
+
** `isDefined<T>(value: T | undefined): value is Defined<T>`
— a type guard that returns `true`, if a given value is not `undefined`.
+
* `type Undefined<T> = T extends undefined ? T : never`
— constructs a type by excluding defined types from `T`.
** `isUndefined<T>(value: T | undefined): value is undefined`
— a type guard that returns `true` if a given `value` is `undefined`.
+
* `type NotNull<T> = T extends null ? never : T`
— constructs a type by excluding `null` from `T`.
+
** `notNull<T>(value: T | null): T`
— returns a given `value`, if it is not null.
Throws a `TypeError` otherwise.
+
** `isNotNull<T>(value: T | null): value is NotNull<T>`
— a type guard that returns `true` if a given value is not `null`.
+
* `type Null<T> = T extends null ? T : never`
— constructs a type by excluding non-`null` types from `T`.
** `isNull<T>(value: T | null): value is null`
— a type guard that returns `true` if a given value is `null`.
+
* `type Present<T> = T extends null | undefined ? never : T`
— constructs a type by excluding `null` and `undefined` from `T`.
+
Same as `NonNullable<T>`, added for consistency with the terminology of the package.
It is defined as a conditional type (not `T & {}`) to ensure support of TS compiler before v4.9.
+
** `present<T>(value: T | null | undefined): T`
— returns a given `value`, if it is defined and is not null.
Throws a `TypeError` otherwise.
+
** `isPresent<T>(value: T | null | undefined): value is Present<T>`
— a type guard that returns `true` if a given `value` is defined and is not `null`.
+
* `type Absent<T> = T extends null | undefined ? T : never`
— constructs a type by excluding non-`null` and defined types from `T`.
** `isAbsent<T>(value: T | null | undefined): value is null | undefined`
— a type guard that return `true` if a given `value` is `null` or `undefined`.

[NOTE]
====
`isDefined` and `isUndefined` use the same check against `void 0`
as the JS code generated by TypeScript for the
https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#optional-chaining[optional chaining],
while TS compiler keeps checks `typeof value === 'undefined'` and `value === undefined` as is.
====


== Type and Instance

* `TypeGuard<T, V extends T> = (value: T) => value is V`
— a function type to check if the value is of a certain type.
+
* `Instance<T, U extends any[] = any[]> = abstract new(...args: U) => T`
— definition for class type reference:
** `isInstanceOf<T, U extends any[] = any[], V = unknown>(type: Instance<T, U>): (value: T | V) => value is T`
— creates a type guard that returns true if a passed argument is an instance of a given `type`.
** `isNotInstanceOf<T, U extends any[] = any[], V = unknown>(type: Instance<T, U>): (value: T | V) => value is V`
— creates a type guard that returns true if a passed argument is not an instance of a given `type`.

[WARNING]
====
The `isInstanceOf`/`isNotInstanceOf` functions generic parameters
are not always correctly recognized by the compiler.
It works as expected for the concrete classes,
but requires explicit type parameter for the TypeScript classes.

[source,typescript]
----
import { isInstanceOf } from '@perfective/common';


class A { public readonly value: string = 'a'; }
class B extends A {}
class C { public readonly c: string = 'value'; }

let x: A | C = new B();

if (isInstanceOf(A)(x)) { // <.>
    x.value; // <.>
}

let xOrError: A | TypeError = new TypeError();
if (isInstanceOf<TypeError>(TypeError)(xOrError)) { // <.>
}

let typeOrRangeError: TypeError | RangeError = new RangeError();
if (isInstanceOf<TypeError>(TypeError)(typeOrRangeError)) { // <.>
}

----
<1> `isInstanceOf` infers class `A` as the type parameter.
<2> Compiler type guards `x` as an instance of `A`.
<3> Explicitly providing the built-in type.
Otherwise, compiler considers `xOrError` as `A | TypeError`.
The function works correctly.
<4> For the union of two built-in type,
even explicit type parameter does not work.
The function works correctly.
====


== ECMA and TypeScript types

JavaScript provides the `typeof` operator that returns 'object' for arrays and `null`.
This results in additional checks needed using this operator.
To reduce this complexity, the `typeOf<T>` function is provided with the conditional `TypeOf<T>` type.

* Types
** `EcmaType`
— is one of `undefined`, `boolean`, `number`, `bigint`, `string`, `symbol`, `function`, or `object`.
** `TsType`
— is one of `EcmaType` or `null`, `array`, and `unknown`.
** `TypeOf<T>`
— a conditional type that returns `TsType` dynamically.
+
* Unit functions:
** `ecmaType(type: EcmaType): EcmaType`
— Type guards an `EcmaType` value in compile time
(unlike the `as` operator which allows to type cast any string as `EcmaType`).
Throws a `TypeError` when the value in runtime is not an `EcmaType`.
** `tsType(type: TsType): TsType`
— Type guards a `TsType` value in compile time
(unlike the `as` operator which allows to type cast any string as `TsType`).
Throws a `TypeError` when the value in runtime is not a `TsType`.
** `typeOf<T>(value: T | null | undefined): TypeOf<T> & TsType`.
— returns the name of a TypeScript type of a given `value`.
+
* Type guards:
** `isEcmaType(input: string): input is EcmaType`
— returns true and narrows the variable type, if the given input string is an `EcmaType`.
** `isTsType(input: string): input is TsType`
— returns true and narrows the variable type, if the given input string is a `TsType`.
+
* Predicates:
** `isTypeOf<T>(type: TypeOf): (value: T | null | undefined) => boolean`
— creates a predicate that returns `true`, if a passed argument is of a given TypeScript type.
** `isNotTypeOf<T>(type: TypeOf): (value: T | null | undefined) => boolean`
— creates a predicate that returns `true`, if a passed argument is not of a given TypeScript type.


== Handling `void`

In TypeScript, `link:https://www.typescriptlang.org/docs/handbook/2/functions.html#void[void]` type
is treated differently from `undefined` and `null`,
and linters provide different rules to restrict its usage only to correct cases.

Unfortunately, different packages (like AWS SDK) may use `void` as a synonym to `null | undefined`.
This approach creates conflicts in the code linted with the
`link:https://github.com/perfective/eslint-config[@perfective/eslint-config]`,
so a special type and function are introduced to "type cast" any `void` value into `null | undefined`:

* `Voidable<T> = T | void`
— a value that is either of type `T` or is `void`.
+
* `voidable<T>(value: T | void): T | null | undefined`
— casts a given `Voidable` value into an optional nullable type.
